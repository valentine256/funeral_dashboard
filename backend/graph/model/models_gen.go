// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

// Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
type IntComparisonExp struct {
	Eq     *int  `json:"_eq,omitempty"`
	Gt     *int  `json:"_gt,omitempty"`
	Gte    *int  `json:"_gte,omitempty"`
	In     []int `json:"_in,omitempty"`
	IsNull *bool `json:"_is_null,omitempty"`
	Lt     *int  `json:"_lt,omitempty"`
	Lte    *int  `json:"_lte,omitempty"`
	Neq    *int  `json:"_neq,omitempty"`
	Nin    []int `json:"_nin,omitempty"`
}

// Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
type StringComparisonExp struct {
	Eq  *string `json:"_eq,omitempty"`
	Gt  *string `json:"_gt,omitempty"`
	Gte *string `json:"_gte,omitempty"`
	// does the column match the given case-insensitive pattern
	Ilike *string  `json:"_ilike,omitempty"`
	In    []string `json:"_in,omitempty"`
	// does the column match the given POSIX regular expression, case insensitive
	Iregex *string `json:"_iregex,omitempty"`
	IsNull *bool   `json:"_is_null,omitempty"`
	// does the column match the given pattern
	Like *string `json:"_like,omitempty"`
	Lt   *string `json:"_lt,omitempty"`
	Lte  *string `json:"_lte,omitempty"`
	Neq  *string `json:"_neq,omitempty"`
	// does the column NOT match the given case-insensitive pattern
	Nilike *string  `json:"_nilike,omitempty"`
	Nin    []string `json:"_nin,omitempty"`
	// does the column NOT match the given POSIX regular expression, case insensitive
	Niregex *string `json:"_niregex,omitempty"`
	// does the column NOT match the given pattern
	Nlike *string `json:"_nlike,omitempty"`
	// does the column NOT match the given POSIX regular expression, case sensitive
	Nregex *string `json:"_nregex,omitempty"`
	// does the column NOT match the given SQL regular expression
	Nsimilar *string `json:"_nsimilar,omitempty"`
	// does the column match the given POSIX regular expression, case sensitive
	Regex *string `json:"_regex,omitempty"`
	// does the column match the given SQL regular expression
	Similar *string `json:"_similar,omitempty"`
}

// order
type Order struct {
	ID       string  `json:"id,omitempty"`
	Name     *string `json:"name,omitempty"`
	Quantity int     `json:"quantity,omitempty"`
}

// aggregated selection of "order"
type OrderAggregate struct {
	Aggregate *OrderAggregateFields `json:"aggregate,omitempty"`
	Nodes     []*Order              `json:"nodes,omitempty"`
}

// aggregate fields of "order"
type OrderAggregateFields struct {
	Avg        *OrderAvgFields        `json:"avg,omitempty"`
	Count      int                    `json:"count,omitempty"`
	Max        *OrderMaxFields        `json:"max,omitempty"`
	Min        *OrderMinFields        `json:"min,omitempty"`
	Stddev     *OrderStddevFields     `json:"stddev,omitempty"`
	StddevPop  *OrderStddevPopFields  `json:"stddev_pop,omitempty"`
	StddevSamp *OrderStddevSampFields `json:"stddev_samp,omitempty"`
	Sum        *OrderSumFields        `json:"sum,omitempty"`
	VarPop     *OrderVarPopFields     `json:"var_pop,omitempty"`
	VarSamp    *OrderVarSampFields    `json:"var_samp,omitempty"`
	Variance   *OrderVarianceFields   `json:"variance,omitempty"`
}

// aggregate avg on columns
type OrderAvgFields struct {
	Quantity *float64 `json:"quantity,omitempty"`
}

// Boolean expression to filter rows from the table "order". All fields are combined with a logical 'AND'.
type OrderBoolExp struct {
	And      []*OrderBoolExp      `json:"_and,omitempty"`
	Not      *OrderBoolExp        `json:"_not,omitempty"`
	Or       []*OrderBoolExp      `json:"_or,omitempty"`
	ID       *UUIDComparisonExp   `json:"id,omitempty"`
	Name     *StringComparisonExp `json:"name,omitempty"`
	Quantity *IntComparisonExp    `json:"quantity,omitempty"`
}

// input type for incrementing numeric columns in table "order"
type OrderIncInput struct {
	Quantity *int `json:"quantity,omitempty"`
}

// input type for inserting data into table "order"
type OrderInsertInput struct {
	ID       *string `json:"id,omitempty"`
	Name     *string `json:"name,omitempty"`
	Quantity *int    `json:"quantity,omitempty"`
}

// aggregate max on columns
type OrderMaxFields struct {
	ID       *string `json:"id,omitempty"`
	Name     *string `json:"name,omitempty"`
	Quantity *int    `json:"quantity,omitempty"`
}

// aggregate min on columns
type OrderMinFields struct {
	ID       *string `json:"id,omitempty"`
	Name     *string `json:"name,omitempty"`
	Quantity *int    `json:"quantity,omitempty"`
}

// response of any mutation on the table "order"
type OrderMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int `json:"affected_rows,omitempty"`
	// data from the rows affected by the mutation
	Returning []*Order `json:"returning,omitempty"`
}

// on_conflict condition type for table "order"
type OrderOnConflict struct {
	Constraint    OrderConstraint     `json:"constraint,omitempty"`
	UpdateColumns []OrderUpdateColumn `json:"update_columns,omitempty"`
	Where         *OrderBoolExp       `json:"where,omitempty"`
}

// Ordering options when selecting data from "order".
type OrderOrderBy struct {
	ID       *OrderBy `json:"id,omitempty"`
	Name     *OrderBy `json:"name,omitempty"`
	Quantity *OrderBy `json:"quantity,omitempty"`
}

// primary key columns input for table: order
type OrderPkColumnsInput struct {
	ID string `json:"id,omitempty"`
}

// input type for updating data in table "order"
type OrderSetInput struct {
	ID       *string `json:"id,omitempty"`
	Name     *string `json:"name,omitempty"`
	Quantity *int    `json:"quantity,omitempty"`
}

// aggregate stddev on columns
type OrderStddevFields struct {
	Quantity *float64 `json:"quantity,omitempty"`
}

// aggregate stddev_pop on columns
type OrderStddevPopFields struct {
	Quantity *float64 `json:"quantity,omitempty"`
}

// aggregate stddev_samp on columns
type OrderStddevSampFields struct {
	Quantity *float64 `json:"quantity,omitempty"`
}

// aggregate sum on columns
type OrderSumFields struct {
	Quantity *int `json:"quantity,omitempty"`
}

// aggregate var_pop on columns
type OrderVarPopFields struct {
	Quantity *float64 `json:"quantity,omitempty"`
}

// aggregate var_samp on columns
type OrderVarSampFields struct {
	Quantity *float64 `json:"quantity,omitempty"`
}

// aggregate variance on columns
type OrderVarianceFields struct {
	Quantity *float64 `json:"quantity,omitempty"`
}

// Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
type UUIDComparisonExp struct {
	Eq     *string  `json:"_eq,omitempty"`
	Gt     *string  `json:"_gt,omitempty"`
	Gte    *string  `json:"_gte,omitempty"`
	In     []string `json:"_in,omitempty"`
	IsNull *bool    `json:"_is_null,omitempty"`
	Lt     *string  `json:"_lt,omitempty"`
	Lte    *string  `json:"_lte,omitempty"`
	Neq    *string  `json:"_neq,omitempty"`
	Nin    []string `json:"_nin,omitempty"`
}

// column ordering options
type OrderBy string

const (
	// in ascending order, nulls last
	OrderByAsc OrderBy = "asc"
	// in ascending order, nulls first
	OrderByAscNullsFirst OrderBy = "asc_nulls_first"
	// in ascending order, nulls last
	OrderByAscNullsLast OrderBy = "asc_nulls_last"
	// in descending order, nulls first
	OrderByDesc OrderBy = "desc"
	// in descending order, nulls first
	OrderByDescNullsFirst OrderBy = "desc_nulls_first"
	// in descending order, nulls last
	OrderByDescNullsLast OrderBy = "desc_nulls_last"
)

var AllOrderBy = []OrderBy{
	OrderByAsc,
	OrderByAscNullsFirst,
	OrderByAscNullsLast,
	OrderByDesc,
	OrderByDescNullsFirst,
	OrderByDescNullsLast,
}

func (e OrderBy) IsValid() bool {
	switch e {
	case OrderByAsc, OrderByAscNullsFirst, OrderByAscNullsLast, OrderByDesc, OrderByDescNullsFirst, OrderByDescNullsLast:
		return true
	}
	return false
}

func (e OrderBy) String() string {
	return string(e)
}

func (e *OrderBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid order_by", str)
	}
	return nil
}

func (e OrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "order"
type OrderConstraint string

const (
	// unique or primary key constraint
	OrderConstraintOrderPkey OrderConstraint = "order_pkey"
)

var AllOrderConstraint = []OrderConstraint{
	OrderConstraintOrderPkey,
}

func (e OrderConstraint) IsValid() bool {
	switch e {
	case OrderConstraintOrderPkey:
		return true
	}
	return false
}

func (e OrderConstraint) String() string {
	return string(e)
}

func (e *OrderConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid order_constraint", str)
	}
	return nil
}

func (e OrderConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "order"
type OrderSelectColumn string

const (
	// column name
	OrderSelectColumnID OrderSelectColumn = "id"
	// column name
	OrderSelectColumnName OrderSelectColumn = "name"
	// column name
	OrderSelectColumnQuantity OrderSelectColumn = "quantity"
)

var AllOrderSelectColumn = []OrderSelectColumn{
	OrderSelectColumnID,
	OrderSelectColumnName,
	OrderSelectColumnQuantity,
}

func (e OrderSelectColumn) IsValid() bool {
	switch e {
	case OrderSelectColumnID, OrderSelectColumnName, OrderSelectColumnQuantity:
		return true
	}
	return false
}

func (e OrderSelectColumn) String() string {
	return string(e)
}

func (e *OrderSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid order_select_column", str)
	}
	return nil
}

func (e OrderSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "order"
type OrderUpdateColumn string

const (
	// column name
	OrderUpdateColumnID OrderUpdateColumn = "id"
	// column name
	OrderUpdateColumnName OrderUpdateColumn = "name"
	// column name
	OrderUpdateColumnQuantity OrderUpdateColumn = "quantity"
)

var AllOrderUpdateColumn = []OrderUpdateColumn{
	OrderUpdateColumnID,
	OrderUpdateColumnName,
	OrderUpdateColumnQuantity,
}

func (e OrderUpdateColumn) IsValid() bool {
	switch e {
	case OrderUpdateColumnID, OrderUpdateColumnName, OrderUpdateColumnQuantity:
		return true
	}
	return false
}

func (e OrderUpdateColumn) String() string {
	return string(e)
}

func (e *OrderUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid order_update_column", str)
	}
	return nil
}

func (e OrderUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
